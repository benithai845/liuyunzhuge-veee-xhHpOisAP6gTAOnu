[合集 - 技术札纪——有限硬件与无限计算的权衡艺术(44)](https://github.com)

[1.书本介绍：技术札纪——有限硬件与无限计算的权衡艺术07-24](https://github.com/poemyang/p/19002322)[2.书本大纲：从芯片、分布式到云计算AI时代07-25](https://github.com/poemyang/p/19004265)[3.我的代码背叛了我？为什么 a=1, b=2，最后x和y都等于0？07-25](https://github.com/poemyang/p/19004704)[4.我的代码出现幻觉？说好的a = 1； x = b，怎么成了x = b； a = 1？07-28](https://github.com/poemyang/p/19008983)[5.为什么i++不是原子操作？一个让无数并发程序崩溃的“常识”07-29](https://github.com/poemyang/p/19010948)[6.没有Happens-Before？你的多线程代码就是‘一锅粥’！07-30](https://github.com/poemyang/p/19012883)[7.Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法07-31](https://github.com/poemyang/p/19014740)[8.a+b=c，处理器一步搞定，Java虚拟机为啥要四步？08-01](https://github.com/poemyang/p/19016482)[9.“同声传译”还是“全文翻译”？为何HotSpot虚拟机仍要保留解释器？08-04](https://github.com/poemyang/p/19020937)[10.“代码跑着跑着，就变快了？”——揭秘Java性能幕后引擎：即时编译器08-05](https://github.com/poemyang/p/19022518)[11.Java编译器优化秘籍：字节码背后的IR魔法与常见技巧08-06](https://github.com/poemyang/p/19024509)[12.解锁硬件潜能：Java向量化计算，性能飙升W倍！08-07](https://github.com/poemyang/p/19026352)[13.new出来的对象，不一定在堆上？聊聊Java虚拟机的优化技术：逃逸分析08-08](https://github.com/poemyang/p/19027777)[14.性能优化之母：为什么说“方法内联”是编译器优化中最关键的一步棋？08-11](https://github.com/poemyang/p/19031406)[15.从纳秒到毫秒的“时空之旅”：CPU是如何看待内存与硬盘的？08-12](https://github.com/poemyang/p/19033086)[16.硬盘性能提升100倍的秘密：看懂顺序I/O的魔力08-14](https://github.com/poemyang/p/19038725)[17.十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解08-18](https://github.com/poemyang/p/19043960)[18.Facebook内部都在用的存储引擎，LSM凭什么能硬扛亿级写入流量？08-21](https://github.com/poemyang/p/19050442)[19.千亿消息“过眼云烟”？Kafka把硬盘当内存用的性能魔法，全靠这一手！08-22](https://github.com/poemyang/p/19052513)[20.RPC的三大问题：跨语言、跨平台通信的终极解决方案是如何炼成的？08-27](https://github.com/poemyang/p/19060527)[21.从文本到二进制：HTTP/2不止于性能，更是对HTTP/1核心语义的传承与革新08-28](https://github.com/poemyang/p/19061836)[22.从HPACK到多路复用，揭秘HTTP/2如何终结网络拥堵08-29](https://github.com/poemyang/p/19063734):[飞数机场](https://ze16.com)[23.站在巨人的肩膀上：gRPC通过HTTP/2构建云原生时代的通信标准09-01](https://github.com/poemyang/p/19068100)[24.gRPC不是银弹：为内网极致性能，如何设计自己的RPC协议？09-03](https://github.com/poemyang/p/19071487)[25.从JSON到Protobuf，深入序列化方案的选型与原理09-04](https://github.com/poemyang/p/19073206)[26.“卧槽，系统又崩了！”——别慌，这也许是你看过最通俗易懂的分布式入门09-05](https://github.com/poemyang/p/19074847)[27.海量数据如何“安家”？一文读懂哈希、范围和一致性哈希三大分片策略09-08](https://github.com/poemyang/p/19079520)[28.“你还活着吗？” “我没死，只是网卡了！”——来自分布式世界的“生死契约”09-09](https://github.com/poemyang/p/19082361)[29.“凭什么说你比我先？”——没有上帝时钟，如何判断“谁先谁后”？09-12](https://github.com/poemyang/p/19087563)[30.“鸡蛋不能放一个篮子里”，如何确保千亿数据万无一失？09-15](https://github.com/poemyang/p/19092154)[31.系统里数据又“打架”了？让“少数服从多数”来终结这场混乱！09-18](https://github.com/poemyang/p/19097975)[32.技术圈的“绯闻女孩”：Gossip是如何把八卦秘密传遍全网的？09-19](https://github.com/poemyang/p/19100196)[33.绯闻女孩不只会八卦：从“验明正身”到“抓内鬼”，Gossip的进阶玩法09-20](https://github.com/poemyang/p/19101931)[34.从混沌到秩序：Java共享内存模型如何通过显式约束驯服并发？09-23](https://github.com/poemyang/p/19106679)[35.一把锁的两种承诺：synchronized如何同时保证互斥与内存可见性？09-24](https://github.com/poemyang/p/19108676)[36.从MESA模型到锁升级：synchronized性能逆袭的底层逻辑09-25](https://github.com/poemyang/p/19110705)[37.揭秘JUC：volatile与CAS，并发编程的两大基石09-27](https://github.com/poemyang/p/19114881)[38.“不要通过共享内存来通信”——深入理解Golang并发模型与CSP理论10-13](https://github.com/poemyang/p/19139419)[39.Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？10-14](https://github.com/poemyang/p/19142146)[40.“一切皆文件”：揭秘LINUX I/O与虚拟内存的底层设计哲学10-15](https://github.com/poemyang/p/19143895)[41.你的程序为何卡顿？从LINUX I/O三大模式寻找答案10-16](https://github.com/poemyang/p/19146666)[42.单线程如何撑起百万连接？I/O多路复用：现代网络架构的基石10-17](https://github.com/poemyang/p/19148798)[43.从C10K到Reactor：事件驱动，如何重塑高并发服务器的网络架构10-20](https://github.com/poemyang/p/19153675)

44.职责分离的艺术：剖析主从Reactor模型如何实现极致的并发性能10-21

收起

**Reactor单线程模型**
在Reactor单线程模型中，所谓的“单线程”主要针对I/O操作而言，即所有的I/O操作（如accept()、read()、write()和connect()）都在同一个线程上完成。然而，在当前的单线程Reactor模型中，不仅I/O操作由Reactor线程处理，非I/O的业务逻辑操作也在该线程上执行。这种设计可能导致I/O请求的响应被显著延迟，因为耗时的业务逻辑会阻塞Reactor线程，使其无法及时处理后续的I/O事件。
为了优化性能，应当将非I/O的业务逻辑操作从Reactor线程中卸载，转交给独立的线程池处理。这样可以显著加速Reactor线程对 I/O请求的响应，提升系统的整体吞吐量和响应速度。
![image](https://img2024.cnblogs.com/blog/757914/202510/757914-20251021202150045-979620940.png)

**Reactor工作者线程池模型**
与单线程模型不同，工作者线程池模型引入了工作者线程池（Work Thread Pool），并将非I/O操作从Reactor线程中剥离，交由工作者线程池执行。这种设计能够显著提升Reactor线程的I/O响应速度，避免因耗时业务逻辑的阻塞而延迟后续I/O请求的处理。
![image](https://img2024.cnblogs.com/blog/757914/202510/757914-20251021202214916-76351506.png)

然而，在工作者线程池模型中，尽管非I/O操作被转移到了线程池中处理，但所有的I/O操作仍然由Reactor单线程执行。在高负载、高并发或大数据量的应用场景中，这种设计仍然可能成为性能瓶颈。因此，为了进一步优化Reactor模型，衍生出了多线程模型，以更好地应对复杂的应用需求。

**Reactor主从多线程模型**
1）MainReactor负责监听Server Socket，处理新连接的建立。通常，MainReactor只暴露一个服务端口，并将建立的Socket连接注册到SubReactor。由于其主要任务是处理新连接，因此通常只需一个线程即可完成。
2）SubReactor负责维护与客户端的实际通信，基于I/O多路复用处理读写事件，完成网络数据的读写操作。SubReactor通常采用多线程设计，线程数一般设置为处理器核心数的两倍，以充分利用多核性能。
对于非I/O操作（如业务逻辑处理），任务会被转交给独立的工作线程池执行，以避免阻塞SubReactor的事件循环。
为了充分利用多核处理器的系统资源，Reactor模型可以被拆分为两部分：MainReactor和SubReactor。
这种设计使得每个模块的职责更加专一，耦合度显著降低，系统的性能和稳定性得到大幅提升，支持的并发客户端数量可以达到百万级别。目前，许多优秀的框架已经成功应用了这种模型，例如Java的Netty等。
![image]()

**Reactor模型和过滤器**
过滤器（Filter）是一种数据处理模式，用于在数据传递过程中进行预处理或后处理。过滤器通常以链式结构（Filter Chain）组织，每个过滤器依次处理数据，负责特定任务（如解码、验证、日志记录等）。
当事件发生时，Reactor将其传递给过滤器链的第一个过滤器。每个过滤器处理后将结果传递给下一个，直到所有过滤器完成处理。最终，处理完成的事件会交给实际的事件处理器进行进一步处理。
过滤器链的优势在于将复杂逻辑分解为一系列简单、独立的步骤，每个步骤由专门过滤器负责。这种设计提高了代码的可读性和可维护性，同时使添加、删除或修改处理步骤更加灵活便捷。
![image]()

**Reactor模型和异步编程**
异步编程是一种编程范式，允许程序在等待某个操作（如I/O操作）完成时继续执行其他任务，从而避免阻塞。异步编程通常通过回调函数、Promise、Future等机制实现。
Reactor模型和异步编程通常结合使用，以实现高效的并发处理。Reactor模型提供事件驱动的基础，而异步编程则用于处理具体的非阻塞操作。
当Reactor监听事件（如网络请求到达）。事件循环接收到事件后，向工作线程池提交一个异步操作（如读取数据）。异步操作返回一个Future对象，表示操作的未来结果。Reactor继续监听其他事件，不阻塞当前线程。当异步操作完成后，Future对象的结果被设置，并触发回调函数。回调函数处理结果，可能触发新的事件（如发送响应）。
![image]()

以下伪代码，展示了Reactor主从多线程模型与滤器链，异步编程结合执行过程。

```
// 伪代码: 主从Reactor与异步处理
// MainReactor循环
mainReactor.onNewConnection(socket -> {
    // 轮询选择一个SubReactor
    SubReactor sub = subReactors.next();
    // 将新连接注册到SubReactor
    sub.register(socket);
});

// SubReactor循环
subReactor.onReadable(socket, data -> {
    // 提交给工作线程池，并返回一个Future
    Future future = workerPool.submit(() -> {
        // 经过过滤器链处理
        data = filterChain.process(data);
        // 执行耗时的业务逻辑
        return businessLogic(data);
    });

    // 异步处理结果
    future.onComplete(result -> {
        socket.write(result); // 将结果异步写回
    });
});
```

**未完待续**

**很高兴与你相遇！如果你喜欢本文内容，记得关注哦**
